#
# Prototype calls for ESDN concepts - single node
#

import os
import time
import scapy.all as scapy
import socket

def aton(ip):
    return socket.inet_aton(ip)


# add worker threads on a core and pause it
#bess.add_worker(0,24)
bess.pause_all()

# create vports and atach it to the containers (created externally)
v_mlocal_1 = VPort(ifname='v_mlocal_1', docker='mlocal_1', mac_addr='02:00:00:00:11:01', ip_addrs=['10.20.21.11/24'])
ans = raw_input("press enter after verifying interface: ")

v_mlocal_2 = VPort(ifname='v_mlocal_2', docker='mlocal_2', mac_addr='02:00:00:00:11:02', ip_addrs=['10.20.21.12/24'])
ans = raw_input("press enter after verifying interface: ")

print("Connection succesful")

pML1_in::PortInc(port=v_mlocal_1)
pML1_out::PortOut(port=v_mlocal_1)
pML2_in::PortInc(port=v_mlocal_2)
pML2_out::PortOut(port=v_mlocal_2)


# -- End Init --


# -- packet generation --
pkt_size = int($BESS_PKT_SIZE!'128')

# check the env vaar in range
assert(60 <= pkt_size <= 1522)

# create packet with provided 5 tuple info
def gen_pkt(dst_ip, dst_mac, src_ip, src_mac, port_no):
    eth = scapy.Ether(src = src_mac, dst = dst_mac)
    ip = scapy.IP(src=src_ip, dst=dst_ip)
    tcp = scapy.TCP(dport=port_no)
    payload = ('packet from ' + src_ip + ' destination ' + dst_ip + ':' + str(port_no))
    pkt = eth/ip/tcp/payload
    return bytes(pkt)

packets = [ gen_pkt('10.20.21.11','02:00:00:00:11:01','10.145.72.121','06:16:3e:1b:72:32',80),
            gen_pkt('10.20.21.11','02:00:00:00:11:01','10.12.45.121','09:ae:67:34:21:02',80),
            gen_pkt('10.20.21.12','02:00:00:00:11:02','10.145.72.121','10:56:f1:44:12:d3',80),
            gen_pkt('10.20.21.12','02:00:00:00:11:02','10.12.46.12','09:87:27:ff:d6:ae',80)
            ]
# -- packet generated

# -- Classifier Functionality
#

# network guid for 10.20.21.0/24 1964ddca-91c3-470a-a68b-d15ec9f4123c
# port_id for v_mlocal_1         74d43679-7c00-4927-91dd-77783e652f63
# port_id for v_mlocal_2         9725d4f1-bb72-414a-8daf-e70e917af6a5
#
# -------------------------------------------------------------
# RGW Module will be doing these functionality
# match based on source IP (L4)

# declare smart switch to route after setmetadata
sm1::SmartSwitch(dp_ids=["1964ddca-91c3-470a-a68b-d15ec9f4123c"])

# L4 protocol and source/destination IP addresses
# offset 23 - protocol  (tcp 06,  udp 17,  icmp 01)
# offset 26 src ip
# offset 30 dst ip -- we will only look at dst ip here

em1::ExactMatch(fields=[{'offset':23, 'num_bytes':1},\
                        {'offset':30, 'num_bytes':4}])

em1.add(fields=[{'value_int':17}, {'value_bin':aton('10.20.21.11')}], gate=0)
em1.add(fields=[{'value_int':06}, {'value_bin':aton('10.20.21.11')}], gate=0)
em1.add(fields=[{'value_int':01}, {'value_bin':aton('10.20.21.11')}], gate=0)
em1.add(fields=[{'value_int':17}, {'value_bin':aton('10.20.21.12')}], gate=1)
em1.add(fields=[{'value_int':06}, {'value_bin':aton('10.20.21.12')}], gate=1)
em1.add(fields=[{'value_int':01}, {'value_bin':aton('10.20.21.12')}], gate=1)

s::Source() -> Rewrite(templates=packets) -> em1

# add a rate militer scheduler to limit number of packets generated per sec
bess.add_tc('pktgen', policy='rate_limit',resource='packet', limit={'packet': 1500000})
s.attach_task('pktgen')

# Smart-switch out gates assignment -- Do "attach" before this to get gate number
# Here we know the two ports, so using directly

gate1 = sm1.attach(dp_id='1964ddca-91c3-470a-a68b-d15ec9f4123c',
                    port_id='74d43679-7c00-4927-91dd-77783e652f63')
gate2 = sm1.attach(dp_id='1964ddca-91c3-470a-a68b-d15ec9f4123c',
                    port_id='9725d4f1-bb72-414a-8daf-e70e917af6a5')

print( "Gate1: " + str(gate1))
print("Gate2: " + str(gate2))

# Add full flow
#em1:0 -> SetMetadata(attrs=[{'name':'Port_ID','size': 16,\
#            'value_bin': b'\x74\xd4\x36\x79\x7c\x00\x49\x27\x91\xdd\x77\x78\x3e\x65\x2f\x63'},
#            {'name':'PortNo','size':1,'value_bin':b'\x01'}]) -> 0:sm1
#em1:1 -> SetMetadata(attrs=[{'name':'Port_ID','size': 16,\
#            'value_bin': b'\x97\x25\xd4\xf1\xbb\x72\x41\x4a\x8d\xaf\xe7\x0e\x91\x7a\xf6\xa5'},
#            {'name':'PortNo','size':1,'value_bin': b'\x02'}]) -> 0:sm1
                                                                                                                    #
em1:0 -> SetMetadata(attrs=[{'name':'PortNo','size':1,'value_int': 0x01}]) -> 0:sm1
em1:1 -> SetMetadata(attrs=[{'name':'PortNo','size':1,'value_int': 0x02}]) -> 0:sm1
                                                                                                                    #
#em1:0 -> SetMetadata(attrs=[{'name':'Port_ID','size': 16,\
#            'value_bin': b'\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11',
#            'offset': 192}]) -> 0:sm1
#em1:1 -> SetMetadata(attrs=[{'name':'Port_ID','size': 16,\
#            'value_bin': b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff',
#            'offset': 192}]) -> 0:sm1
                                                                                                                    #
sm1:1 ->  pML1_out
sm1:2 ->  pML2_out

pML1_in -> 1:sm1
pML2_in -> 2:sm1

# in real network, this is the default output port tyically NIC or a gateway
sm1:0 -> Sink()

bess.resume_all()

